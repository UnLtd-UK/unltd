---
/**
 * Individual Resource Page - Canonical URL
 * Flat URL structure: /spaces/[resource-slug]
<<<<<<< HEAD
 *
 * Only generates pages for resources that belong to at least one PUBLIC space.
 * Resources that only belong to restricted spaces are not generated.
=======
 * Access control based on spaces the resource belongs to:
 * - If belongs to ANY public space → public access
 * - If only in restricted spaces → requires authentication
>>>>>>> 9d79ac1 (Refactor resource and space pages to improve URL structure and access control)
 */

import slugify from "slugify";
import Template from "@layouts/Template.astro";
import Container from "@components/Container.astro";
import Breadcrumbs from "@components/Breadcrumbs.astro";
import Default from "@components/heroes/Default.astro";
import Content from "@components/markdoc/Content.astro";
import TableOfContents from "@components/TableOfContents.astro";
<<<<<<< HEAD
=======
import SpaceAuth from "@components/SpaceAuth.astro";
>>>>>>> 9d79ac1 (Refactor resource and space pages to improve URL structure and access control)

import { allSpaces } from "@data/spaces.js";
import { allResources } from "@data/resources.js";
import { prepareMarkdown } from "@data/functions/prepareMarkdown.ts";
import { prepareToc } from "@data/functions/prepareToc.ts";
<<<<<<< HEAD
import { getEffectiveAccess } from "@utils/spaceAccess";
=======
>>>>>>> 9d79ac1 (Refactor resource and space pages to improve URL structure and access control)

// Type definitions
interface Space {
    id: string;
    name: string;
    description: string;
<<<<<<< HEAD
    unlisted: boolean;
=======
    access: "public" | "unlisted" | "restricted";
>>>>>>> 9d79ac1 (Refactor resource and space pages to improve URL structure and access control)
    restricted_password?: string;
    eventbrite_keywords?: string[];
}

interface ResourceSpace {
    spaces_id?: { id: string; name: string };
}

interface Resource {
    id: string;
    name: string;
    description: string;
    body?: string;
    type: "guide" | "video" | "form" | "external";
<<<<<<< HEAD
    topic?: string;
=======
    category?: string;
>>>>>>> 9d79ac1 (Refactor resource and space pages to improve URL structure and access control)
    external_url?: string;
    spaces?: ResourceSpace[];
}

interface TocHeading {
    id: string;
    level: number;
    text: string;
}

export async function getStaticPaths() {
    const paths: Array<{
        params: { resource: string };
        props: {
            resource: Resource;
            resourceSlug: string;
            body: string;
            toc: TocHeading[];
<<<<<<< HEAD
            isListed: boolean;
=======
            isPublic: boolean;
            restrictedSpaces: Space[];
>>>>>>> 9d79ac1 (Refactor resource and space pages to improve URL structure and access control)
        };
    }> = [];

    // Get all guide resources (those with body content)
    const guideResources = (allResources as Resource[]).filter(
        (resource) => resource.type === "guide" && resource.body,
    );

    for (const resource of guideResources) {
        const resourceSlug = slugify(resource.name, {
            lower: true,
            strict: true,
            locale: "en",
            trim: true,
        });

        const body = prepareMarkdown(resource.body || "");
        const toc = prepareToc(body);

        // Determine access based on spaces this resource belongs to
        const resourceSpaceIds = (resource.spaces || [])
            .map((s) => s.spaces_id?.id)
            .filter(Boolean);

        const resourceSpaces = (allSpaces as Space[]).filter((space) =>
            resourceSpaceIds.includes(space.id),
        );

<<<<<<< HEAD
        // Get effective access based on highest priority space
        const effectiveAccess = getEffectiveAccess(resourceSpaces);

        // Only generate pages for resources that have PUBLIC access
        // Skip resources that only belong to restricted spaces
        if (!effectiveAccess.isPublic) {
            continue;
        }

        const isListed = effectiveAccess.isListed;
=======
        // If belongs to ANY public space, it's public
        const isPublic = resourceSpaces.some(
            (space) => space.access === "public",
        );

        // Get restricted spaces for auth (only needed if not public)
        const restrictedSpaces = isPublic
            ? []
            : resourceSpaces.filter((space) => space.access === "restricted");
>>>>>>> 9d79ac1 (Refactor resource and space pages to improve URL structure and access control)

        paths.push({
            params: {
                resource: resourceSlug,
            },
            props: {
                resource,
                resourceSlug,
                body,
                toc,
<<<<<<< HEAD
                isListed,
=======
                isPublic,
                restrictedSpaces,
>>>>>>> 9d79ac1 (Refactor resource and space pages to improve URL structure and access control)
            },
        });
    }

    return paths;
}

<<<<<<< HEAD
const { resource, resourceSlug, body, toc, isListed } = Astro.props as {
    resource: Resource;
    resourceSlug: string;
    body: string;
    toc: TocHeading[];
    isListed: boolean;
};
=======
const { resource, resourceSlug, body, toc, isPublic, restrictedSpaces } =
    Astro.props as {
        resource: Resource;
        resourceSlug: string;
        body: string;
        toc: TocHeading[];
        isPublic: boolean;
        restrictedSpaces: Space[];
    };
>>>>>>> 9d79ac1 (Refactor resource and space pages to improve URL structure and access control)

// Breadcrumbs
const breadcrumbs = [
    { name: "Spaces", path: "/spaces" },
    { name: resource.name, path: `/spaces/${resourceSlug}` },
];

<<<<<<< HEAD
// noindex if unlisted
const shouldNoindex = !isListed;
=======
// For restricted resources, use the first restricted space for auth
const authSpace = restrictedSpaces[0];
>>>>>>> 9d79ac1 (Refactor resource and space pages to improve URL structure and access control)
---

<Template
    name={resource.name}
    description={resource.description}
<<<<<<< HEAD
    noindex={shouldNoindex}
>
    <Container>
        <Breadcrumbs breadcrumbs={breadcrumbs} />
        <div class="mt-8">
            <Default name={resource.name} description={resource.description} />
        </div>
=======
    noindex={!isPublic}
>
    {/* Password protection for restricted resources */}
    {
        !isPublic && authSpace && (
            <SpaceAuth
                spaceSlug={slugify(authSpace.name, {
                    lower: true,
                    strict: true,
                    locale: "en",
                    trim: true,
                })}
                spaceName={authSpace.name}
                password={authSpace.restricted_password || ""}
                access={authSpace.access}
            />
        )
    }

    <Container>
        <Breadcrumbs breadcrumbs={breadcrumbs} />
        <Default name={resource.name} description={resource.description} />
>>>>>>> 9d79ac1 (Refactor resource and space pages to improve URL structure and access control)

        <div class="flex gap-8 lg:gap-12 pb-16 items-start">
            {/* Table of Contents - Desktop Sidebar */}
            <aside class="hidden lg:block sticky top-24">
                <TableOfContents headings={toc} variant="desktop" />
            </aside>

            {/* Main Content */}
            <article class="flex-1 min-w-0">
                <div
                    class="bg-violet-900/30 rounded-2xl ring-1 ring-violet-700/50 p-6 sm:p-8 lg:p-10"
                >
                    <Content body={body} />
                </div>
            </article>
        </div>
    </Container>

    {/* Mobile Table of Contents */}
    <TableOfContents headings={toc} variant="mobile" />
</Template>
